<link rel="import" href="../elements/app-layout.html">
<link rel="import" href="../elements/awall-menu.html">

<polymer-element name="layout-workspace" extends="app-layout">
    <template>
        <style>
            #container {
                display: flex;
                flex-direction: column;
            }

            header, footer {
                color: white;
                padding: 1em;
                background-color: #000000;
            }

            header {
                display: none;
            }

            footer {
                position: fixed;
                Width: 100%;
                bottom: 0;
                height: 2em;
                z-index: 200;
            }

            #body {
                flex: 1;
                padding: 0.3em;
                display: flex;
                flex-direction: column;
                margin-bottom: 4em;
            }

            #widgets {
                display: flex;
            }

            .widgetDropzone {
                flex: 1 1 10%;
                margin-right: 0.3em;
                margin-bottom: 0.3em;
                height: 13em;
                box-sizing: border-box;
                position: relative;
            }

            @media only screen and (max-height: 40rem) {
                .widgetDropzone {
                    height: 3.5em;
                }
            }

            #widgetmain {
                position: relative;
                height: 100%;
                width: 100%;
            }

            .hidden {
                display: none;
            }

            a {
                color: white;
                padding: 0 1em;
            }
        </style>
        <div id="container">
            <header>HEADER</header>
            <div id="body">
                <div id="widgets">
                    <div class="widgetDropzone hidden" id="widgetDropzone1"></div>
                    <div class="widgetDropzone hidden" id="widgetDropzone2"></div>
                    <div class="widgetDropzone hidden" id="widgetDropzone3"></div>
                    <div class="widgetDropzone hidden" id="widgetDropzone4"></div>
                    <div class="widgetDropzone hidden" id="widgetDropzone5"></div>
                    <div class="widgetDropzone hidden" id="widgetDropzone6"></div>
                    <div class="widgetDropzone hidden" id="widgetDropzone7"></div>
                    <div class="widgetDropzone hidden" id="widgetDropzone8"></div>
                    <div class="widgetDropzone hidden" id="widgetDropzone9"></div>
                    <div class="widgetDropzone hidden" id="widgetDropzone10"></div>
                    <awall-menu id="menu"></awall-menu>
                </div>
                <div id="widgetDropzonemain"></div>
            </div>

            <template if="{{!$.globals.isSmallScreenHeight}}">
                <footer>
                    <template repeat="{{workspace in $.globals.workspaces}}">
                        <a href="{{workspace.parsedPath}}">
                            {{workspace.name}}
                        </a>
                    </template>
                </footer>
            </template>
        </div>
        <app-core id="globals"></app-core>
    </template>
    <script>
        (function () {

            /**
             * Represents a widget dropzone.
             */
            function WidgetDropzone(position, dropzoneElement) {
                this.position = position;
                this.dropzoneElement = dropzoneElement;
            }

            /**
             * Check whether this dropzone has a widget;
             *
             * @returns {boolean} true if it has a widget, false otherwise.
             */
            WidgetDropzone.prototype.hasWidget = function () {
                return this.widget !== undefined && this.widget !== undefined;
            };

            /**
             * Sets the widget of the dropzone.
             *
             * @param widget The widget object.
             * @param view The document-fragment with the widget's view.
             */
            WidgetDropzone.prototype.setWidget = function (widget, view) {
                if (this.hasWidget()) {
                    console.error('This widget dropzone already has a widget.');
                    return;
                }

                if (!view) {
                    console.error('Given view is null or undef.');
                    return;
                }

                var target = this.dropzoneElement;

                // create container with shadow root and add the view
                var container = document.createElement('div');
                var root = container.createShadowRoot();
                container.style.height = '100%';
                root.appendChild(document.importNode(view, true));

                target.appendChild(container);

                if (root.children.length === 0) {
                    console.error('Failed to add widget ' + widget.id + ' to ' + target.getAttribute('id'));
                    return;
                }

                target.classList.remove('hidden');

                this.widget = widget;
                this.view = view;
            };

            /**
             * Removes the widget's view from the dropzone.
             */
            WidgetDropzone.prototype.removeWidget = function () {
                if (!this.hasWidget()) {
                    console.error('This widget dropzone has no widget to remove.');
                    return;
                }

                var target = this.dropzoneElement;

                var container = target.children[0];
                if (!container) {
                    console.error('Container-element not found for dropzone ' + target.getAttribute('id'));
                    return;
                }

                target.removeChild(container);

                target.classList.add('hidden');

                this.widget = undefined;
                this.view = undefined;
            };


            Polymer(Polymer.mixin({
                /**
                 * List of added widgets.
                 */
                widgets: [],
                /**
                 * List of dropzones.
                 */
                dropzones: [],
                /**
                 * Sorted list of info-view widget (without main widget).
                 * Sorted by position.
                 */
                sortedInfoViewWidgets: [],
                /**
                 * Map of widget.id -> view (HTML element)
                 */
                widgetIdToView: {},
                /**
                 * Minimal widget size in pixel.
                 */
                minWidgetWidthInPx: 300,
                /**
                 * Number of widgets that can be comfortably displayed.
                 */
                widgetsToDisplay: 0,
                /**
                 * Maximum number of widgets that can be shown.
                 * Should match the number of dropzones in the DOM-tree.
                 */
                maxWidgetsToDisplay: 10,
                /**
                 * Called when widgetsToDispaly changes.
                 * Recalculates which widgets should be shown.
                 */
                widgetsToDisplayChanged: function (oldVal, newVal) {
                    var a, b;
                    var isRemove = oldVal > newVal;
                    if (isRemove) {
                        a = newVal;
                        b = oldVal;
                    } else {
                        a = oldVal;
                        b = newVal;
                    }

                    for (var i = a; i < b; i++) {
                        var dropzone = this.dropzones[i];
                        if (isRemove) {
                            dropzone.removeWidget();
                        } else {
                            if (!dropzone.hasWidget()) {
                                var widget = this.sortedInfoViewWidgets[i];
                                var view = this.widgetIdToView[widget.id];
                                dropzone.setWidget(widget, view);
                            }
                        }
                    }

                    // adjust the width of the widget
//                        if (widget.width > 1) {
//                            // widget may be max. 50% of width
//                            var widgetWidth = widget.width > 5 ? 5 : widget.width;
//                            targetView.style.flexBasis = (10 * widgetWidth) + '%';
//                        }

                },
                /**
                 * Calculates the number of widgets to display.
                 * Sets widgetsToDisplay variable if it has changed.
                 */
                evaluateWidgetsToDisplay: function () {
                    var availableWidgetWidth = this.$.widgets.clientWidth - this.$.menu.clientWidth;
                    var newWidgetsToDisplay = Math.floor(availableWidgetWidth / this.minWidgetWidthInPx);
                    newWidgetsToDisplay = Math.max(newWidgetsToDisplay, 1);
                    if (newWidgetsToDisplay !== this.widgetsToDisplay) {
                        this.widgetsToDisplay = newWidgetsToDisplay;
                    }
                },
                domReady: function () {
                    for (var i = 1; i <= this.maxWidgetsToDisplay; i++) {
                        var dropzoneElement = this.$['widgetDropzone' + i];
                        this.dropzones.push(new WidgetDropzone(i, dropzoneElement));
                        // activate dropzone
                        this.touch.makeDropzone(dropzoneElement, {
                            accept: '.widget'
                        });
                    }

                    this.sortedInfoViewWidgets = this.widgets.filter(function (widget) {
                        return widget.position !== 'main';
                    }).sort(function (a, b) {
                        return a.position >= b.position ? 1 : -1;
                    });


                    this.evaluateWidgetsToDisplay();
                    // add resize listener (called every time the browser window is resized)
                    window.addEventListener('resize', this.evaluateWidgetsToDisplay.bind(this));
                },
                created: function () {
                    this.widgets = [];
                    this.widgetIdToView = {};
                    this.dropzones = [];
                },
                addWidget: function (widget, widgetNode) {
                    this.widgets.push(widget);
                    this.widgetIdToView[widget.id] = widgetNode;

                    if (widget.position === 'main') {
                        var targetId = 'widgetDropzone' + widget.position;
                        var targetView = this.$[targetId];

                        if (targetView === null) {
                            console.error('No element with the ID ' + targetId + ' exists, cannot add widget ' + widget.id);
                            return;
                        }

                        this.setView(targetId, widgetNode);
                    }
                }
            }, window.appMixin));
        })();
    </script>
</polymer-element>
