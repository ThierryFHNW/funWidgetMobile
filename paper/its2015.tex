\documentclass{sigchi}

% Use this command to override the default ACM copyright statement
% (e.g. for preprints).  Consult the conference website for the
% camera-ready copyright statement.

%% EXAMPLE BEGIN -- HOW TO OVERRIDE THE DEFAULT COPYRIGHT STRIP -- (July 22, 2013 - Paul Baumann)
% \toappear{Permission to make digital or hard copies of all or part of this work for personal or classroom use is      granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. Copyrights for components of this work owned by others than ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. Request permissions from permissions@acm.org. \\
% {\emph{CHI'14}}, April 26--May 1, 2014, Toronto, Canada. \\
% Copyright \copyright~2014 ACM ISBN/14/04...\$15.00. \\
% DOI string from ACM form confirmation}
%% EXAMPLE END -- HOW TO OVERRIDE THE DEFAULT COPYRIGHT STRIP -- (July 22, 2013 - Paul Baumann)

% Arabic page numbers for submission.  Remove this line to eliminate
% page numbers for the camera ready copy 
% \pagenumbering{arabic}

% Load basic packages
\usepackage{balance}  % to better equalize the last page
\usepackage{graphics} % for EPS, load graphicx instead 
%\usepackage[T1]{fontenc}
\usepackage{txfonts}
\usepackage{times}    % comment if you want LaTeX's default font
\usepackage[pdftex]{hyperref}
% \usepackage{url}      % llt: nicely formatted URLs
\usepackage{color}
\usepackage{textcomp}
\usepackage{booktabs}
\usepackage{ccicons}
%\usepackage{todonotes}
\usepackage{listings}


\usepackage[font=normalsize,labelfont=bf]{caption}
\usepackage{subcaption}

\usepackage[acronym]{glossaries}

% llt: Define a global style for URLs, rather that the default one
\makeatletter
\def\url@leostyle{%
  \@ifundefined{selectfont}{\def\UrlFont{\sf}}{\def\UrlFont{\small\bf\ttfamily}}}
\makeatother
\urlstyle{leo}

% To make various LaTeX processors do the right thing with page size.
\def\pprw{8.5in}
\def\pprh{11in}
\special{papersize=\pprw,\pprh}
\setlength{\paperwidth}{\pprw}
\setlength{\paperheight}{\pprh}
\setlength{\pdfpagewidth}{\pprw}
\setlength{\pdfpageheight}{\pprh}

% Make sure hyperref comes last of your loaded packages, to give it a
% fighting chance of not being over-written, since its job is to
% redefine many LaTeX commands.
\definecolor{linkColor}{RGB}{6,125,233}
\hypersetup{%
  pdftitle={SIGCHI Conference Proceedings Format},
  pdfauthor={LaTeX},
  pdfkeywords={SIGCHI, proceedings, archival format},
  bookmarksnumbered,
  pdfstartview={FitH},
  colorlinks,
  citecolor=black,
  filecolor=black,
  linkcolor=black,
  urlcolor=linkColor,
  breaklinks=true,
}

\newcommand\todo[1]{~\\\\~\\~\\~\\~\\~\textbf{\huge{\textcolor{red}{#1}}}\\~\\~\\~\\~\\~}


% code listing style https://en.wikibooks.org/wiki/LaTeX/Source_Code_Listings
\lstset{
	frame=single,
	numbers=left,
	numbersep=5pt,
	breaklines=true,
	numberstyle=\tiny,
	showstringspaces=false,
	basicstyle=\small\ttfamily,
	captionpos=b
}


% create a shortcut to typeset table headings
% \newcommand\tabhead[1]{\small\textbf{#1}}


% End of preamble. Here it comes the document.
\begin{document}

\title{From Large Touch Walls to Tablets -- a Responsive Web Framework for Large Multi-Touch Wall Applications}

\numberofauthors{3}
\author{%
  \alignauthor{1st Author Name\\
    \affaddr{Affiliation}\\
    \affaddr{City, Country}\\
    \email{e-mail address}}\\
  \alignauthor{2nd Author Name\\
    \affaddr{Affiliation}\\
    \affaddr{City, Country}\\
    \email{e-mail address}}\\
  \alignauthor{3rd Author Name\\
    \affaddr{Affiliation}\\
    \affaddr{City, Country}\\
    \email{e-mail address}}\\
}

\maketitle

\newacronym{spa}{SPA}{single-page application}
\newacronym{dom}{DOM}{Document Object Model}
\newacronym{rwd}{RWD}{responsive web design}
\newacronym{sp1}{SP1}{sprint planning 1}
\newacronym{sp2}{SP2}{sprint planning 2}
\newacronym{uri}{URI}{uniform resource identifier}


\begin{abstract}
Agile software development is a highly collaborative and communication intensive method in modern software development.  One of its characteristics is the usage of large pin boards with cards where the team does the whole project planning. In this paper we present \textit{aWall}, a responsive web application framework that supports the collaborative teamwork using large multi-touch wall systems and tablets for interacting with the system as a team and as an individual. Combining these two interaction methods present unique challenges with respect to the UI and the flow of information. We describe \textit{aWall}'s Web UI architecture and implementation for a concrete case study to showcase the collaborative nature of the application with special focus on its responsive design approach, interaction and information dissemination in the multi-device environment.
\end{abstract}

\category{H.5.2.}{Information Interfaces and Presentation (e.g. HCI)}{User Interfaces -- \textit{Interaction styles}}
\category{H.5.3.}{Information Interfaces and Presentation (e.g. HCI)}{Group and Organization Interfaces -- \textit{Computer-supported cooperative work}}
\category{H.5.4.}{Information Interfaces and Presentation (e.g. HCI)}{Hypertext/Hypermedia -- \textit{Architectures}}


\keywords{Collaborative work and interaction; multi-touch; wall; tablets; responsive design; agile; sprint planning 2; web components}

\section{Introduction}
% agile sw dev intro
Agile promises that a project is finished on time, delivers high quality software, well constructed and maintainable code and that agile teams make the users happy \cite{Stellman:2014}.
The core of agile is a set of practices and methodologies around self-organizing teams relying on face-to-face communication \cite{Cockburn:2001}.
According to recent study in Switzerland, 70\% of all IT companies practice agile software development and 83\% of all IT professionals \cite{Kropp:2015}.
Agile software development projects are split into short iterations usually lasting between 2-4 weeks. In Scrum these iterations are called sprints.
% What is SP2?
The user requirements for the software system are described in \textit{user stories}, a brief description of a feature in everyday language.
All \textit{user stories} are stored in a \textit{product backlog} and are maintained by a \textit{product owner}, who represents the customer to the development team and who is in charge of all requirements.
Each sprint starts with a \textit{sprint planning meeting}, which is divided in two sub meetings. In the \gls{sp1} meeting, the team and the product owner select those user stories, which will be implemented in the next iteration.
The selected user stories are stored in a list called the \textit{sprint backlog}.
In the \gls{sp2} meeting, the team then splits the selected user stories from the \textit{sprint backlog} into smaller technical tasks, which describe what the developer has to do to implement the user story. These tasks should not take longer than one workday to complete.

The traditional and most often used way to this, is to write the user stories and tasks on cards and attach them on a large pin or magnetic board.
The setup on the board is called a \textit{taskboard}. This board is typically divided into three columns (ToDo, in progrees, done) which indicate the progress of the individual tasks. This allows the team to easily see the state and progress of the current sprint. While a physical card wall offers many advantages in respect of ease of use and flexibility, it also has major disadvantages compared to digital solutions. However, recent studies \cite{udcw:31721, Mateescu:2015} show that current desktop-based digital solutions can hardly fulfill the requirements concerning agile collaboration.

% paper to digital
Large digital multi-touch wall systems have the potential to be able to replace the physical boards and offering even more possibilities, amongst are also support for distributed team collaboration. However as \cite{udcw:31721} and \cite{Mateescu:2015} show, they must provide the natural interaction and ease of use as physical boards. 
% - tablets for collaborative work
In \cite{Mateescu:2015} we present a concept for a large multi-touch wall based agile collaboration platform. The agile software development process comprises of different kinds of meetings, which can all be held at the wall. For some of the meetings a direct interaction with the wall, respectively with the artifacts represented at the wall, seem less appropriate. Other, smaller, input devices like individual developers tablets or even smartphones might be more appropriate. These devices allow multiple people to directly and independently interact with the artifacts on the wall and enter or modify data during the meeting more comfortable; still everybody immediately seeing the changes made. 
In the collaborative \gls{sp2} meeting, where everyone helps in creating tasks for the next iteration, tablets can be used to create the tasks in an interconnected web application.

% - responsive web design
The responsive web design (RWD) \cite{Marcotte:2011} approach offers a solution to create one application that provides an optimal viewing experience across a wide variety of different devices with various display-resolutions. 
% - mobile-first, we: wall -> tablet "wall-first"
A term often heard in the context of RWD is mobile-first \cite{Wroblewski:2011}. 
It is an approach to give the mobile site a higher priority and design it with the constraints and capabilities of small-screen devices in mind. 
Since we already developed the UI for the large multi-touch wall, our challenge was to find a suitable design for the tablet without sacrificing functionality.

% sp2 as focus
To showcase the features of the \textit{aWall} web application, we are going to use the \gls{sp2} meeting as an example.

% - structure of the paper
The remainder of the paper is structured as follows.
First, related work is presented.
Then the UI design and the challenges we faced when adapting a web application designed for large screens to smaller tablet-sized screens.
In the next section, we present the architecture of the system we developed and how we tackled the challenges.
The following section describes the implementation and in the end, we discuss the work and provide an outlook into our future work.

\section{Related Work}
% Scrum taskboards stuff:
An often mentioned and typical setting used in the agile process is the taskboard.
It shows the current progress of the project iteration at a glance and is used in the daily stand-up meetings. 
A digital tabletop application is introduced for agile planning meetings in \cite{Ghanam:4599452}. 
The tabletop only has a single-touch display. 
Thus only one person can interact with the system at a time and without advanced gestures that involve multiple fingers like pinch-to-zoom.
In \cite{Rubart:2014:CMS:2669485.2669551}, a cooperative multi-touch taskboard for large displays is proposed. 
The paper discusses how interactive tabletops and surfaces can be applied to the agile taskboard for the daily stand-up and other meetings and evaluates gestures known from smartphones for big tabletops and group settings.
\cite{Haas:2014:TAV:2669485.2669538} introduces a task assignment system for tabletop computers that consists of two components: the tabletop application and a separate Android companion application.
The companion application shows changes made on the tabletop in real-time and offers some limited interaction capabilities.

% wall, tablet stuff
A multi-surface communication and collaboration platform using a wall, tabletops and tablets for an emergency operations center is presented in \cite{Chokshi:2014:EMM:2669485.2669520}. 
The system is spatially aware of all the devices and people in the room using multiple Kinects.
This allows the use of gestures like a flick on a tablet towards the wall to share information.
The device types are used for different scenarios:
The tablet is used for personal and private interaction with colleagues.
Whereas the tabletop is a semi-private workspace for collaboration and the wall is a public information radiator, aggregating multiple data sources.
The authors developed native applications for the wall, the tabletop and the tablet.
Thus multiple independent applications were developed with different code bases using in part the same information provided by servers.
% one web application to rule them (devices) all
With \textit{aWall}, we do not want to maintain multiple code bases but one application to handle all the devices.
This includes the viewing experience corresponding to the device type of what is shown and how it is presented.


% Responsive design:
One of the most significant challenges with the emergence of all the new devices like smartphones, tablets and phablets in the last years, is device and platform fragmentation.
Developing a unique experience for each device would mean to have an application per device type.
This also means multiple times the work if something needs to be changed. 
By using a single code base that serves a multitude of devices, a maintenance nightmare can be avoided.
For the web, HTML5 and CSS3 bring many advancements to create a single code base for different device and screen sizes.
The approach using a single application is called \gls{rwd}.
In \cite{Pandey:2013:RDT:2525194.2525271}, the author presents a case study of a mobile-first design process used to create a hybrid smartphone and tablet application for transaction banking.

% Proximity of user and responsive design:
What responsive design does not take into account is the proximity of the user. 
The authors in \cite{Sukale:2014:PWD:2638728.2638768} developed an example implementation of a responsive web application that adjusts the information displayed according to the user's distance to the display.

%Collaborative web visualization:
In \cite{Badam:2014:PCF:2669485.2669518}, an web-based application framework is presented for collaborative visualizations across multiple devices. The framework allows to synchronize UI state of new or legacy web applications with minimal overhead.


\section{UI Design and Challenges}
\subsection{General Layout}
% context
The agile process has multiple collaborative meetings that deal with different aspects of the project.
% Workspace layout (info-view with widgets, workspace menu, main widget)
The UI of \textit{aWall} in Figure~\ref{fig:awall-layout} is built around workspaces configured with independent widgets that can be used by several workspaces.
For each meeting there is a workspace configured with the most appropriate widgets.
Each workspace consists of a main widget that takes most of the available space, numerous independent widgets in a panel at the top of the screen, called info-view, and the workspace-menu with options to configure the workspace.

\begin{figure}[h]
	\centering
	\includegraphics[width=\columnwidth]{figures/awall-layout}
	\caption{UI layout of \textit{aWall} with a main widget for \gls{sp2} on a device larger than a tablet but smaller than the wall.}~\label{fig:awall-layout}
\end{figure}

% main widget
The main widget occupies the largest part of the UI and is the main working area.
For each meeting of the agile process there is a specialized main widget that shows exactly what is needed and offers tailored interaction methods.
Supplemental interaction with additional artifacts is provided by the widgets in the info-view.
Each main widget is responsible for the responsive behavior of its content to show the appropriate amount of information depending on the available space.


% info view and widgets
The info-view is the horizontal panel at the top with the smaller widgets.
% responsiveness of number of widgets in the layout (min. width for widgets)
The widgets in the info-view can have different widths from standard width to multiple-times the standard-width.
The number of widgets to display is calculated by the application and depends on the width of the viewport.
If a currently hidden widget is enabled, the widget in the last position is replaced with the enabled widget.
This ensures that the widgets always have enough space.
Widgets that do not fit can be accessed by the workspace-menu, where each widget can be enabled or disabled. 


% widget abilities (dock, resize etc)
The widgets in Figure~\ref{fig:awall-layout} are in a docked position but can be undocked by dragging them out of the info-view.
When a widget is dragged out of the info-view (undocked) the space is closed whereby all widgets to the right move one position to the left.
If a widget is to be docked again, the widget's space is freed up with all widgets to the right moving one position to the right.
With this, the widgets can be freely arranged by the user.
Once undocked, the widget can be moved around the viewport and resized by either using the mouse or the pinch-to-zoom gesture on a multi-touch display. 

% widgets sizes (title, default, full, edit mode)
The widgets can have multiple views for different sizes when being resized.
In the docked position in the info-view the widgets show the default view on larger screens. 
% responsiveness of the view (widget height with title only and default size)
On smaller screens like on a tablet, only the title of the widget is shown, henceforward called title-only view.
The default size with the same functionality as on larger screens is shown when it is undocked.
Besides the title-only and the default view, a widget can offer an additional full view and an edit mode.
The full view is intended to show more information on the widget's subject or offer additional interaction functionality.
It is triggered by specifying the breakpoints for the width and height.
Once the widget has exceeded both breakpoints while resizing, the full view is shown.
% - buttons when undocked (dock, reset size, enter edit mode)
If a widget has an edit mode, an edit icon is displayed in the top-right corner of the widget.
There are two more buttons on all widgets: one to reset the size to the default view and one that docks the widget in the info-view.


% workspace menu
% workspace menu: save/reset workspace, list of widgets with toggle to en/disable, list of available meeting workspaces
The workspace-menu is the small button in the top right corner.
It allows to control which widgets are enabled and disabled with toggles, to switch to other workspaces for the other meetings and to save or reset the current workspace configuration.
As mentioned above, the widgets in the info-view can be rearranged.
The new arrangement can be saved by the user or reset to the default.


\subsection{SP2 Layout}
The main widget for the \gls{sp2} meeting, as depicted in Figure~\ref{fig:awall-layout}, shows the \textit{sprint backlog} on the left and a panel on the right for unassigned tasks.
Unassigned tasks are specific to our solution and they represent the paper-based card written by a team member that has not been discussed by the team and thus has not been assigned to a user story yet.
This is where the tablets comes into play.
Each team member has a tablet and creates tasks with it.
As soon as the task is created on a tablet, it is sent to all devices connected to the system and pops up on the wall.
Then it is discussed and finally either assigned to a user story or discarded.

% responsiveness of sp2 workspace; 2 "views": large screen and small screen (sprint view: show all US, US view: show selected US and all tasks + temp tasks)
On the wall, everything including the \textit{sprint backlog} and the unassigned tasks can be shown simultaneously.
The tablet does not have enough space to show all the information like on the wall.
Thus we split the widget into two views:
The first view (Figure \ref{fig:sp2-overview}) shows all the user stories of the \textit{sprint backlog} in a grid.
When the user clicks, respectively selects a user story, the second view is shown, called detail view (Figure \ref{fig:sp2-detail}).
There the selected user story with all its tasks and the list of unassigned tasks is displayed.


\begin{figure*}
	\centering
	\begin{subfigure}[b]{1\columnwidth}
		\includegraphics[width=\textwidth]{figures/sp2-overview}
		\caption{Overview}
		\label{fig:sp2-overview}
	\end{subfigure}%
	\quad
	\begin{subfigure}[b]{1\columnwidth}
		\includegraphics[width=\textwidth]{figures/sp2-detail}
		\caption{Detailed view}
		\label{fig:sp2-detail}
	\end{subfigure}
	
	\caption{The two views of the split up \gls{sp2} user interface for smaller displays.}\label{fig:sp2-smallscreen-views}
\end{figure*}


\subsection{Challenges}
The two device types the system uses, namely the wall and hand-held tablets, have significantly different screen resolutions and physical dimensions. 
An important goal driving our design was the ability to see everything without scrolling.
Supporting these different devices with one code base and adhere to the no scrolling requirement presents some challenges:

\begin{itemize}
	\item \textbf{Retain functionality:} 
	Even though the screen of a tablet is not as small as a smartphones', the available space is significantly smaller than on the large multi-touch wall. 
	A big challenge was to retain the same functionality on the tablet as on the wall. Often when going from a large screen to a smaller one, functionality is sacrificed in order to  keep it organized and legible.
	
	\item \textbf{Reduce space of non-essential elements:}
	% title-only view => undock => default view
	A lot of vertical space is used up by the info-view widgets.
	They offer auxiliary functionality, but it is not absolutely essential that they are completely visible the whole time in their default view.
	Thus, we created the title-only view for the widgets.
	That way, the widgets are still in the same place and visible, but have to be dragged out of the info-view to be usable.
	Once the widget is undocked, it enlarges to the default size and it can be used like on the wall.
	
	\item \textbf{Viewing experience: focused vs. overview:}
	In our collaborative scenario of the \gls{sp2} meeting, the wall and the tablet serve different needs.
	The wall's duty is to give the whole team the overview of the whole sprint, while the tablet's focus lies with the individual to create new tasks for the currently discussed user story.
	This requires the information displayed on the device to be specific to its purpose.
	While the complete \textit{sprint backlog} is important on the wall, it is not relevant for creating a task for a user story.
	Thus, we split the main widget for the \gls{sp2} meeting into two views on smaller screens as depicted in Figure \ref{fig:sp2-smallscreen-views}.
	
\end{itemize}


\section{Architecture}

\subsection{System Overview}

%- System overview (Server, JIRA, REST API)
The whole system consists of four components, as depicted in Figure~\ref{fig:systemoverview}:
\begin{itemize}
	\item \textit{aWall} web application: The \textit{aWall} application is a \gls{spa} and is built using HTML, Javascript and CSS.
	
	\item A web server: A web server delivers the \textit{aWall} web application files to clients.
	
	\item Application server: An application server that provides a REST API for \textit{aWall} to retrieve the data about the sprints, user stories, tasks and team members.
	It also provides a WebSocket endpoint for real-time updates.
	
	\item A data backend: The data used by the REST API is provided by a backend. 
	Currently, the system uses JIRA \cite{jira} as a backend. JIRA is a bug, issue and project management software used by many software development teams around the world.
\end{itemize}

\begin{figure}[h]
	\centering
	\includegraphics[width=\columnwidth]{figures/systemoverview}
	\caption{System overview.}~\label{fig:systemoverview}
\end{figure}

% Awall web app delivered by the web server:
\textit{aWall} is a \gls{spa}, that means that the website is not rendered by an application server and then sent to the client but is rendered completely on the client.
It also means that the website does not reload, even when another page of the website is loaded. 
The resources like images and scripts are loaded dynamically when needed and added to the application at runtime.
The information about sprints, user stories and tasks is retrieved from the application server over the REST API.
The data is delivered in a light-weight format called JSON. 

\subsection{Web Components}
%- HTML5 WebComponents to isolate functionality (JS) and style (CSS)
\textit{aWall} uses Web Components \cite{webcomponents.org}, a set of four standards currently being produced as a W3C specification.
Those four specifications offer the following features that can be used together or individually:
\begin{itemize}
	\item Custom Elements~\cite{CustomElements} Define and use new HTML elements. 
	That ranges from simple format-elements to complex elements with functionality like, for example, the HTML5 video element.
	
	\item HTML Imports~\cite{HTMLImports}: Include and reuse HTML documents.
	Allows to define custom elements in a separate file,  import it and then use those custom elements. 
	Similar to how CSS and Javascript files can be imported.
	
	\item The template element~\cite{TemplateElement}: Declare inactive \gls{dom}-trees that can be reused to instantiate custom elements.
	
	\item Shadow DOM~\cite{ShadowDOM}: Encapsulate functionality and style in \gls{dom}-trees.
	Normally CSS definitions are global no matter where they are defined.
	By encapsulating the style definitions in a Shadow DOM, they become local and scoped and do not affect any other \gls{dom} elements outside of the Shadow DOM.
\end{itemize}

%- nested, reusable elements instead of MVC
The application is composed of nested custom HTML elements and does not follow the more traditional MVC pattern. 
This approach goes more in the direction of component-based software engineering that emphasizes the separation of concerns.
The custom elements can be defined in separate HTML documents and be reused in multiple web applications by importing the document.
This also means that the elements can be loosely-coupled and independent.
Even the access to the REST API is encapsulated in an element. 
To use the REST API, another element only needs to instantiate the appropriate custom element by inserting the corresponding HTML tag into its own HTML.


\subsection{Configuration}

%- Workspace config/definition in a json file (widget position, width, hidden)
The workspaces that make up the web application are configured in JSON files, as seen in Listing~\ref{lst:sp2-config}. 
Apart from a name and the description for the workspace, a path, a layout and widgets must be defined. 

\lstset{caption={Configuration for the \gls{sp2} workspace.},label=lst:sp2-config}
\begin{lstlisting}
{
  "name": "Sprint Planning 2 Workspace",
  "description": "Plan a sprint collaboratively.",
  "path": "/project/:projectId/sprint/:sprintId/sp2",
  "layout": "workspace",
  "widgets": {
    "sprintplanning2": {
      "position": "main",
      "hidden": false
    },
    "sprintinfo": {
      "position": 1,
      "width": 1,
      "hidden": false
    },
    "teamview": {
      "position": 2,
      "width": 2,
      "hidden": false
    }
  }
}
\end{lstlisting}


% path property
The \textit{path} attribute in the configuration represents the fragment identifier, the part of the URL after the hash character (\#).
The fragment identifier refers to a resource that is ancillary to another primary resource, the \gls{uri}.
In a \gls{spa}, the \gls{uri} is the path to the web application itself and the fragment identifier represents the state of the application respectively the current website.
The path attribute in the configuration is composed of fixed words and words prefixed with semicolons, the variables.
As the Listing~\ref{lst:sp2-config} shows, the \gls{sp2} workspace has two varibales, 'projectId' and 'sprintId'.
The two variables are mapped to real IDs at runtime and are replaced by values like 'projectId' =\textgreater 'ATBD' and 'sprintId' =\textgreater '10204', resulting in the string '/project/ATBD/sprint/10204/sp2'.
Without those two variables, the application could not fetch the appropriate information from the server required for the given workspace.

% layout property
A workspace must define which layout to use.
It defines which visual elements (e.g. main widget, info-view, workspace-menu) are displayed and how they are arranged.
The \textit{aWall} application currently has two layouts; One is for simple selection pages, for example selecting the sprint which only has a main widget.
The other is the workspace layout as seen in Figure~\ref{fig:awall-layout} with the info-view at the top with all the additional widgets and the main widget in the center of the layout.
% widgets property
The \textit{widgets} attribute defines all the widgets the workspace has and each widget's configuration in the layout.
Each widget defines its position, its width and whether it is hidden by default.
A workspace must have at least one widget, the main widget which has the positional value of 'main'.

\subsection{Application Start-up}
% how the application is loaded (simple)
The web application loads all workspace configuration files first, then determines which workspace to load by examining fragment identifier of the \gls{uri}.
The requested workspace is then loaded by importing the HTML file that defines the layout and all the defined widget's HTML files.
Some custom elements are used in multiple widgets and are thus defined in their own HTML document.
For example the custom element that represents a task, called taskcard, is defined in taskcard.html and imported by the widgets that use it.
Those elements are imported directly by using the HTML Imports specification.
Once the layout and the widgets have been loaded, they are instantiated and inserted into the layout according to their configuration attributes like position and width.
The layout is then set as the body of the HTML \gls{dom}-tree.

\subsection{Information Dissemination}
%-How information is propagated (e.g. new task created)
%-> WebSocket message to all clients (replace in-place, no website reload)
The REST API alone only offers communication by means of request and response.
To make the application more dynamic, the application server also provides a WebSocket \cite{websocketRFC} endpoint.
WebSocket is bi-directional communication protocol designed to be implemented by web browsers and web servers.
It allows both participants (client and server) to send asynchronous messages for real-time communication.
Once the client has established the connection, it is persistent until closed explicitly.
WebSocket allows the web application not only to recognize changes made by itself, but also changes made by other instances of the web application on different devices no matter where they are.
This works because all instances of the web application establish a WebSocket connection to the application server when started.
If, for example a task has been modified, the task is saved by the application server in the backend and then the information about the change is propagated to all clients over the WebSocket connection.
When the web application receives an update, it checks whether the current workspace uses this task.
If that is the case, the task is updated in-place without reloading the page.
Has a task been created for a user story, it will pop-up on all connected devices in real-time.

\subsection{Responsive Design}
% cornerstones of rwd
For the UI, the web application uses an approach called \gls{rwd} that builds on three cornerstones~\cite{Marcotte:2011}:
\begin{itemize}
	\item Relative units: The style and layout definitions should use relative units like percent instead of fixed units like pixel. A pixel is on a 1080p smartphone display does not have the same physical size as a pixel on a 1080p 24" desktop display. 
	
	\item Flexible images: The images are sized in relative units but there may also be multiple versions of the same image. For example, a low resolution image for small-screen devices and a higher resolution image for larger devices.
	
	\item Media Queries: Media Queries are the main cornerstone of \gls{rwd}. They allow us to define breakpoints with conditional statements in the stylesheet at which different CSS style definitions take effect.
\end{itemize}

Media Queries have been introduced in CSS3 and became a W3C standard in June 2012 \cite{mediaqueriesW3C}.
They allow the content of a website to adapt to the conditions of the web browser.
The most prominent example of such a condition is the screen resolution.
By defining break-points, using for example the width of the viewport, the statement defines the style of the given \gls{dom} element.
% media query example
Let's assume we have a simple element with a title in a h1-element and a text in a p-element.
The media query could define that the p-element is hidden when the height of the viewport is less than 500 pixels.


\section{Implementation}
%- Polymer, Interact.js
\subsection{Frameworks}
The \textit{aWall} web application uses Polymer~\cite{polymer}, a library that abstracts WebComponents and allows to define custom elements using declarative HTML tags instead of pure Javascript code.
This makes it easy to write new custom elements without the huge amount of boilerplate code that is required when using the native Javascript APIs directly.
For multi-touch gestures like pinch-to-zoom, drag\&drop and resizability of elements, \textit{aWall} uses the interact.js~\cite{interactJs} library.

\subsection{Widgets}
% how widgets are implemented by the developer developing widgets
All the widgets use the custom element \textit{awall-widget}.
It gives all the widgets the features like drag \& drop and resizability.
The four views of the widgets are also implemented by custom elements, namely \textit{awall-widget-title}, \textit{awall-widget-size-default}, \textit{awall-widget-size-full} and \textit{awall-widget-editable}.
Listing~\ref{lst:widget-elements} shows the pattern on how a widget is implemented using the aforementioned elements.
The title for a widget is given as the parameter to the attribute \textit{value} for the element \textit{awall-widget-title}.
For the other three view elements, the content is more comprehensive than just a string and thus is enclosed in the element's tags as indicated using HTML comment syntax.

\lstset{caption={HTML elements for the widget's different views.},label=lst:widget-elements}
\begin{lstlisting}
<awall-widget>
  <awall-widget-title value="Team" />

  <awall-widget-size-default>
    <!-- Content for default view -->
  </awall-widget-size-default>

  <awall-widget-size-full showHeight="500" showWidth="400">
    <!-- Content for full view -->
  </awall-widget-size-full>

  <awall-widget-editable showHeight="500" showWidth="400">
    <!-- Content for edit mode -->
  </awall-widget-editable>
</awall-widget>
\end{lstlisting}

Not all the view elements must be used of course.
A widget does not need to have a full view or an edit mode.
Both are optional and can be configured using the two parameters \textit{showHeight} and \textit{showWidth} to define their breakpoints at which point they activate and the default view is hidden.
The edit mode is not shown automatically, but is represented by an edit button appearing when both breakpoints have been exceeded.


% how the custom element awall-widget is implemented by the framework
The \textit{awall-widget} custom element implements the features that all widgets have and controls when which view is displayed.
Listing~\ref{lst:awall-widget} depicts part of the template of the \textit{awall-widget} custom element.
The \textit{content} element is used in Shadow DOM and represents an insertion point for \gls{dom}-trees.
That means that everything between the start and end tag of \textit{awall-widget-size-default} in Listing~\ref{lst:widget-elements} is inserted in the position of the content tag that selects the \textit{awall-widget-size-default} in line 4 of Listing~\ref{lst:awall-widget}.


\lstset{caption={Part of the awall-widget custom element's template using insertion points for the different HTML tags.},label=lst:awall-widget}
\begin{lstlisting}
<content select="awall-widget-title" />

<div id="extendedContent">
  <content select="awall-widget-size-default" />
  <content select="awall-widget-size-full" />
  <content select="awall-widget-editable" />
</div>
\end{lstlisting}


% visibility of the views
All elements in the template in Listing~\ref{lst:awall-widget} except \textit{awall-widget-title} are enclosed in an div-element whose visibility is controlled by the media query shown in Listing~\ref{lst:awall-widget-mediaquery}.
As long as the browsers viewport height is smaller than the defined \textit{max-height} breakpoint, only the title of the widget is shown.
When the widget is dragged out of the info-view, the default view becomes visible.
The widget can now be resized using the pinch-to-zoom gesture or the mouse.
During resizing, the width and height of the widget are compared to the \textit{showHeight} and \textit{showWidth} breakpoints defined for the full view and the edit mode.


\lstset{caption={Media Query hiding all the views except the title when the screen is small enough.},label=lst:awall-widget-mediaquery}
\begin{lstlisting}
@media only screen and (max-height: 40rem) {
  #extendedContent {
    display: none;
  }
}
\end{lstlisting}

\subsection{SP2 Widget}
As mentioned before, each widget is responsible for its own responsive behavior.
The main widgets use the \textit{awall-widget} but with drag \& drop and resizability disabled.
The main widget for the \gls{sp2} workspace, as depicted in Listing~\ref{lst:sp2-template}, has two templates that are controlled by the boolean variable \textit{isSmallScreenHeight}.
The variable is set by the application's Javascript code and is accessible through Polymer's data binding mechanism.
Depending on the value of the variable one of the two inactive templates is activated.
The views are all compartmentalized into their own custom elements and thus the two templates in Listing~\ref{lst:sp2-template} only contain one element (results in Figure~\ref{fig:sp2-overview}) for the small-screen view and two elements for the large-screen view, that results in Figure~\ref{fig:awall-layout}.
The \textit{awall-userstory-cardlist} element for small screens handles its behavior to switch to the detailed view (Figure~\ref{fig:sp2-detail}) itself.
The title for the widget at the top of the listing is visible on any screen and thus is not enclosed in a template.

\lstset{caption={How the \gls{sp2} main widget decides which view to show.},label=lst:sp2-template}
\begin{lstlisting}
<h2>Sprintplanning 2</h2>

<template if="{{isSmallScreenHeight}}">
  <awall-userstory-cardlist />
</template>

<template if="{{!isSmallScreenHeight}}">
  <awall-sprintbacklog />
  <awall-temptasks />
</template>
\end{lstlisting}


\section{Discussion}

% discussion Awall (how great it is)
The framework we developed with \textit{aWall} show, that current web technologies and emerging new web standards make it possible to build a responsive web application for different sized devices. 
The fact that it is an \gls{spa} and uses asynchronous messages for updates over WebSockets allows the application to run on multiple devices with the displayed data always up-to-date without the need to reload the website.
The framework is also designed to be easily extendable with additional workspaces, layouts and widgets.
Through its design using loosely-coupled components or in the web context custom elements, there are no dependencies between the widgets.

\todo{More discussion text}


% WebComponents: rapid development (0.5 -> 1.0), many changes
% only works natively with Chrome, polyfills for other browsers

% use of RWD (ad/disadvantages) in aWall

% the two views of SP2 for small-screen devices


\section{Future Work}
%results from taskboard UI tests (-> tasks for future work)?
After the design of the large-screen UI, we conducted some live-action interviews with developers to discover if the wall could be something they want to work with and to get input on how to improve it.
%meetings with a distributed team (e.g. show movement when a task is dragged) [similar to PolyChrome]
In the future, we are going to build on the input we received and would also like to extend the wall to work with distributed teams, where the movements  of a task for instance are mirrored on other walls.
%handwriting ability



\balance{}

% REFERENCES FORMAT
% References must be the same font size as other body text.
\bibliographystyle{SIGCHI-Reference-Format}
\bibliography{references}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End: